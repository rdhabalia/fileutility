
# ObjectTofile:

Sometimes, we want to pull data from Database and want to write this data into file with specific format. It requires effort to 
1.	Pull records from the database and store it as java objects into memory
2.	Prepare mapping of java objects to specific format (data or metadata)
3.	Maintain size of file
4.	Maintain output directory and File name format configuration
5.	Process parallel to make it quick.

It would be great if framework does above all thing automatically and application just requires few configuration to make them happen. 


i.e:

We have user database:
```
firstName | lastName | id | role.
```
And we want to create a text file which should follow below format:

```
UserFile:User_001.txt
941231253323430034~User~95125~95050
941345345453454453~User~95145~95044
941545453323430023~User~95115~95053
944334353323430000~User~95105~95052
Total~4
```

```
Format
lastName File name
firstName~lastName~id~role
:
:
Total~TotalRecord
```

In order to achieve it we need to write configuration file which specifies format and how to write file out of List<Record>

1.	Create Record object

We need to create POJO which should have column id that can be used in step 2:

```
public class UserRecord implements Record{
	
	@Column(id=0)
	public String firstName;
	@Column(id=1)
	public String lastName
	@Column(id=2)
	public String id;
	@Column(id=3)
	public String role;
   }
```


2.	Specify template :

```
Template dataTemplate = new  DefaultTextFileTemplate("Data");
dataTemplate.appendElement(new Token(0));
dataTemplate.appendElement(new Text("~"));
dataTemplate.appendElement(new Token(1));
dataTemplate.appendElement(new Text("~"));
dataTemplate.appendElement(new Token(2));
dataTemplate.appendElement(new Text("~"));
dataTemplate.appendElement(new Token(3));
```

It describes Template with name "Data" and it has format:
ColumnId1~ ColumnId2~ ColumnId3~ ColumnId4

Above column Id would automatically fetched from provided record  and in our case it is UserRecord.


3.	Map Record to the template

```
Template dataTemplate = new  DefaultTextFileTemplate("Data");
dataTemplate.appendElement(new Token(0));
dataTemplate.appendElement(new Text("~"));
dataTemplate.appendElement(new Token(1));
dataTemplate.appendElement(new Text("~"));
dataTemplate.appendElement(new Token(2));
dataTemplate.appendElement(new Text("~"));
dataTemplate.appendElement(new Token(3));
   
List<Record> data = getuserData();
ClassificationData dataClassification = new ClassificationData(dataTemplate,data,false,9000);
```

We defined ClassificationData which maps template and records. It also contains maximum occurrence of that data in a given file. 

In our case, we require 9000 records per file and rest of the records will be written into next file.


4.	Specify File configuration:

```
String fileName = "user.txt";
String directoryName = "temp/user";
String MIMEType= ".txt";
String postfix = "sdfsfg234234sdfs"; //UniqueId for this process
FileConfiguration fileConfig = new FileConfiguration(directoryName,fileName,MIMEType,postFix);
```
	Framework will append a sequence number to each newly created file in order to give unique name.


5.	Define your own data generator class also:

Here, we a specific requirement for the last Tag which Total:

TOTAL contains total records of the file and it can be varied file to file . This dynamic content can be generated by user_defined class which will be used as CallBack class into the framework.

Here, FirstLine (FileName) and LastLine(TOTAL records) are metadata of the file because if will not be repeated and it doesnï¿½t require any data from the database. So, we will treat meta and data in different way.
In our case, data {firstName,lastName,id,role} is a record which defined by a POJO (UserRecord.java) and meta is (FileName and TOTAL).


Please check ShipmentFeedGenerator.java which generates List<FileChunk>. Each FileChunk represents a one file with contents in it, ShipmentFeedGenerator.java is under test package only.

6.	Final Configuration file is ready:

```
public class ShipmentuserBigTest {

	public void test(){
		
		//Define FileName and configuration
		String fileName = "user.txt";
		FileConfiguration fileConfig = new FileConfiguration("D:/temp/batch", fileName,".txt","123");
		
		TemplateFeeder feeder = new DefaultTemplateFeeder();
		//Define userdefined FileChunk generator: It generates FileChunk for an each file.
		ChunkGenerator generator = new ShipmentFeedGenerator();
		BaseStarter starter = new DefaultProcessStarter();
		
		
		Configuration config = new Configuration(fileConfig, generator);
		//Parallel File processing
		config.setProcessingType(FileEnum.ASYNC);

		//Define set of template and its appropriate records
		List<ClassificationData> layoutChunk = new ArrayList<ClassificationData>();
		
		//Define First line of template
		Template headerTemplate = new  DefaultTextFileTemplate("Header");
		headerTemplate.appendElement(new Text("Header~"+fileName));
		ClassificationData headerClassification = new ClassificationData(headerTemplate,null,true,1);
		
		layoutChunk.add(headerClassification);
		
		//Define Data template
		Template dataTemplate = new  DefaultTextFileTemplate("Data");
		dataTemplate.appendElement(new Token(0));
		dataTemplate.appendElement(new Text("~"));
		dataTemplate.appendElement(new Token(1));
		dataTemplate.appendElement(new Text("~"));
		dataTemplate.appendElement(new Token(2));
		dataTemplate.appendElement(new Text("~"));
		dataTemplate.appendElement(new Token(3));
		List<Record> data = getuserData();
		ClassificationData dataClassification = new ClassificationData(dataTemplate,data,false,9000);
		layoutChunk.add(dataClassification);

		//Define last line template (TOTAL)		
		Template summaryTemplate = new  DefaultTextFileTemplate("Summary");
		summaryTemplate.appendElement(new Text("Total~"));
		ClassificationData summaryClassification = new ClassificationData(summaryTemplate,null,true,1);
		layoutChunk.add(summaryClassification);
		
		long start = Calendar.getInstance().getTimeInMillis();
		try {
		//Start Execution 
			starter.executeFeedProcessing(layoutChunk, config);
		} catch (BaseAppException e) {
			e.printStackTrace();
			ExceptionUtil.logException(e, LogLevel.ERROR);
		}
		long end = Calendar.getInstance().getTimeInMillis();
		System.out.println("Total Time: "+(end-start)/1000);
		
		
	}
}
```
